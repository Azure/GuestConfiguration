
######################################################
#  End to end guest configuration reporting test
#  Verify repot is sent for every consistency run of a 
#  configuration assignement.
######################################################
$ErrorActionPreference = 'Stop'

# Import-Module "$PSScriptRoot\..\..\Common\AzHelper.psm1"

$dscConfigScriptPath = "$PSScriptRoot\DSCConfig.ps1"
$dscConfigFolderPath = "$PSScriptRoot\DSCConfig"
$mofDocPath = "$dscConfigFolderPath\localhost.mof"
$testOutputPath = "$PSScriptRoot\output"
$policyName = 'testPolicy'

Describe 'Test Guest Configuration Custom Policy cmdlets' -Tags @('PSCoreBVT', 'BVT') {
    BeforeAll {

	# Make sure traffic is using TLS 1.2 as all Azure services reject connections below 1.2
	[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        Install-Module -Name xTimeZone -AllowClobber -Force
        Install-Module -Name GuestConfiguration -AllowClobber -AllowPreRelease -Force
        if ($IsWindows) {
            Install-Module -Name 'PSPKI' -Repository 'PSGallery' -Force
        }
        Import-Module "$PSScriptRoot/ProxyFunctions.psm1" -Force
        Import-Module 'PSDesiredStateConfiguration' -Force

$dscConfig = @"
Configuration DSCConfig
{
    Import-DSCResource -ModuleName xTimeZone

    Node 'localhost'
    {
        xTimeZone TimeZoneExample
        {
            IsSingleInstance = 'Yes'
            TimeZone         = 'Tonga Standard Time'
        }
    }
}
DSCConfig -OutputPath $dscConfigFolderPath
"@
        Set-Content -Path $dscConfigScriptPath -Value $dscConfig
        & $dscConfigScriptPath

        Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process

        If ($IsWindows) {
            Import-Module PSPKI -Force
        
            # Create self signed certificate
            New-SelfsignedCertificateEx `
                -Subject "CN=testcert" `
                -EKU 'Code Signing' `
                -KeyUsage 'KeyEncipherment, DataEncipherment, DigitalSignature' `
                -FriendlyName 'DSC Credential Encryption certificate' `
                -Exportable `
                -StoreLocation 'LocalMachine' `
                -KeyLength 2048 `
                -ProviderName 'Microsoft Enhanced Cryptographic Provider v1.0' `
                -AlgorithmName 'RSA' `
                -SignatureAlgorithm 'SHA256'
        }
    }
    BeforeEach {
        Remove-Item $testOutputPath -Force -Recurse -ErrorAction SilentlyContinue
    }
    AfterAll{
        Remove-Item "$PSScriptRoot\DSCConfig.ps1" -Force -ErrorAction SilentlyContinue
        Remove-Item $dscConfigFolderPath -Force -Recurse -ErrorAction SilentlyContinue
        Remove-Item $testOutputPath -Force -Recurse -ErrorAction SilentlyContinue
    }

    It 'Create Custom policy package and test its contents' {
        $package = New-GuestConfigurationPackage -Configuration $mofDocPath -Name $policyName -Path $testOutputPath\package

        # Verify package exists
        Test-Path $package.Path | Should Be $true
        # Verify package name
        $package.Name | Should Be $policyName

        # Verify package contents
        $temp = "$testOutputPath\temp"
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        [System.IO.Compression.ZipFile]::ExtractToDirectory($package.Path, $temp)
        # Verify mof document exists.
        Test-Path "$temp\$policyName.mof" | Should Be $true

        # Test required modules are included in the package
        $resourcesInMofDocument = [Microsoft.PowerShell.DesiredStateConfiguration.Internal.DscClassCache]::ImportInstances("$temp\$policyName.mof", 4) 
        for ($i = 0; $i -lt $resourcesInMofDocument.Count; $i++) {
            if($resourcesInMofDocument[$i].CimInstanceProperties.Name -contains 'ModuleName') {
                Test-Path "$temp\Modules\$($resourcesInMofDocument[$i].ModuleName)" | Should Be $true
            }
        }
    }

    It 'Verify Test-GuestConfigurationPackage can validate the package generated by New-GuestConfigurationPackage' {
        $result = New-GuestConfigurationPackage -Configuration $mofDocPath -Name $policyName -Path $testOutputPath\package | Test-GuestConfigurationPackage

        $result.complianceStatus | Should Be $false
        $result.resources[0].ModuleName | Should Be 'xTimeZone'
        $result.resources[0].complianceStatus | Should Be $false
        $result.resources[0].ConfigurationName | Should Be 'DSCConfig'
        $result.resources[0].IsSingleInstance | Should Be 'Yes'
    }

    It 'Verify Protect-GuestConfigurationPackage cmdlet can sign policy package' {
        $Cert = Get-ChildItem -Path cert:\LocalMachine\My | Where-Object {($_.Subject -eq "CN=testcert") } | Select-Object -First 1
        $package = New-GuestConfigurationPackage -Configuration $mofDocPath -Name $policyName -Path $testOutputPath\package
        Protect-GuestConfigurationPackage -Path $package.Path -Certificate $Cert 

        # Bug: Protect-GuestConfigurationPackage should return the path of signed package.
        $signedPackagePath = Join-Path (Get-ChildItem $package.Path).DirectoryName "$($policyName)_signed.zip"
        $temp = "$testOutputPath\temp"
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        [System.IO.Compression.ZipFile]::ExtractToDirectory($signedPackagePath, $temp)

        $catFilePath = Join-Path $temp "$policyName.cat"
        Test-Path $catFilePath | Should Be $true
        (Get-AuthenticodeSignature $catFilePath).SignerCertificate.Thumbprint | Should Be $Cert.Thumbprint
    }

    It 'Verify New-GuestConfigurationPolicy cmdlet can create custom policy definitions' {
        $testpolicyName = 'AuditWindowsService'
        $contentURI = 'https://github.com/microsoft/PowerShell-DSC-for-Linux/raw/amits/custompolicy/new_gc_policy/AuditWindowsService.zip'
        $policyPath = "$testOutputPath\policyDefinitions"
        $displayName = '[unittest] Audit Windows Service.'
        $description = 'Policy to audit Windows service state.'

        New-GuestConfigurationPolicy -ContentUri $contentURI `
                             -DisplayName $displayName `
                             -Description $description `
                             -Path $policyPath `
                             -Version 1.0.0.0

        # Bug: New-GuestConfigurationPolicy should return the path where policy are generated.
        # Test Audit policy definition
        $policyFile = join-path $policyPath 'AuditIfNotExists.json'
        $jsonDefinition = Get-Content $policyFile | ConvertFrom-Json | ForEach-Object {$_}
        $jsonDefinition.properties.displayName.Contains($displayName) | Should Be $true
        $jsonDefinition.properties.description.Contains($description) | Should Be $true
        $jsonDefinition.properties.policyType | Should Be 'Custom'
        $jsonDefinition.properties.policyRule.then.details.name | Should Be $testpolicyName

        # Test DeployIfNotExist policy definition
        $policyFile = join-path $policyPath 'DeployIfNotExists.json'
        $jsonDefinition = Get-Content $policyFile | ConvertFrom-Json | ForEach-Object {$_}
        $jsonDefinition.properties.displayName.Contains($displayName) | Should Be $true
        $jsonDefinition.properties.description.Contains($description) | Should Be $true
        $jsonDefinition.properties.policyType | Should Be 'Custom'
        $jsonDefinition.properties.policyRule.then.details.deployment.properties.parameters.configurationName.value | Should Be $testpolicyName
        $jsonDefinition.properties.policyRule.then.details.deployment.properties.parameters.contentHash.value | Should Be 'D421E3C8BB2298AEC5CFD95607B91241B7D5A2C88D54262ED304CA1FD01370F3'
        $jsonDefinition.properties.policyRule.then.details.deployment.properties.parameters.contentUri.value | Should Be $contentURI
    }

    It 'Verify Publish-GuestConfigurationPolicy cmdlet can publish the custom policy generated by New-GuestConfigurationPolicy cmdlets' {
        Mock Get-AzContext -MockWith {@{Name = 'Subscription';Subscription=@{Id='Id'}}}            
        Mock Get-AzPolicyDefinition
        Mock Get-AzPolicySetDefinition
        Mock New-AzPolicyDefinition -Verifiable
        Mock New-AzPolicySetDefinition -Verifiable
        
        $testpolicyName = 'AuditWindowsService'
        $contentURI = 'https://github.com/microsoft/PowerShell-DSC-for-Linux/raw/amits/custompolicy/new_gc_policy/AuditWindowsService.zip'
        $policyPath = "$testOutputPath\policyDefinitions"
        $displayName = '[unittest] Audit Windows Service.'
        $description = 'Policy to audit Windows service state.'

        New-GuestConfigurationPolicy -ContentUri $contentURI `
                             -DisplayName $displayName `
                             -Description $description `
                             -Path $policyPath `
                             -Version 1.0.0.0 | Publish-GuestConfigurationPolicy

        # Test published policy
        $existingPolicies = Get-AzPolicyDefinition | Where-Object {($_.Properties.PSObject.Properties.Name -contains 'displayName') -and ($_.Properties.displayName.Contains($displayName))}
        $existingInitiative = Get-AzPolicySetDefinition  | Where-Object {($_.Properties.PSObject.Properties.Name -contains 'displayName') -and ($_.Properties.displayName.Contains($displayName))}

        Remove-AzPolicySetDefinition -Name $existingInitiative.Name -Force
        Remove-AzPolicyDefinition -Name $existingPolicies[0].Name -Force
        Remove-AzPolicyDefinition -Name $existingPolicies[1].Name -Force

        $existingPolicies.Count | Should Be 2
        $existingInitiative -ne $null | Should Be $true
   }
}
